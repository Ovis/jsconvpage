<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>INSERT文カラム編集ツール</title>
  <style>
    body {
      font-family: "Segoe UI", Arial, sans-serif;
      margin: 2rem;
      background-color: #f8f9fb;
      color: #222;
    }
    h1 {
      font-size: 1.75rem;
      margin-bottom: 1rem;
    }
    textarea {
      width: 100%;
      min-height: 140px;
      padding: 0.75rem;
      font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
      font-size: 0.95rem;
      border: 1px solid #ccc;
      border-radius: 4px;
      resize: vertical;
      box-sizing: border-box;
      background-color: #fff;
    }
    button {
      margin-top: 0.75rem;
      padding: 0.6rem 1.4rem;
      font-size: 0.95rem;
      color: #fff;
      background-color: #0078d7;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    button:disabled {
      background-color: #94b8e6;
      cursor: not-allowed;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1.5rem;
      background-color: #fff;
    }
    th, td {
      padding: 0.75rem;
      border: 1px solid #d0d7de;
      vertical-align: top;
      word-break: break-all;
    }
    th {
      background-color: #eef3fb;
      text-align: left;
    }
    .actions {
      margin-top: 1.5rem;
    }
    .options {
      margin-top: 0.75rem;
    }
    .options label {
      font-size: 0.95rem;
      user-select: none;
    }
    .output {
      margin-top: 1.5rem;
    }
    .error {
      margin-top: 0.75rem;
      color: #c62828;
      font-weight: bold;
    }
    .success {
      margin-top: 0.75rem;
      color: #2e7d32;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>INSERT文カラム編集ツール</h1>

  <label for="sqlInput">INSERT文を入力してください:</label>
  <textarea id="sqlInput" placeholder="INSERT ..."></textarea>
  <div>
    <button id="parseBtn">INSERT文を解析</button>
  </div>

  <div id="feedback" role="alert"></div>

  <div id="tableContainer"></div>

  <div class="actions">
    <button id="removeBtn" disabled>選択されたカラムを削除</button>
  </div>

  <div class="options">
    <label><input type="checkbox" id="formatCheckbox"> 結果を整形して表示</label>
  </div>

  <div class="output">
    <label for="outputSql">生成されたINSERT文:</label>
    <textarea id="outputSql" readonly></textarea>
  </div>

  <script>
    const sqlInput = document.getElementById('sqlInput');
    const parseBtn = document.getElementById('parseBtn');
    const removeBtn = document.getElementById('removeBtn');
    const tableContainer = document.getElementById('tableContainer');
    const outputSql = document.getElementById('outputSql');
    const feedback = document.getElementById('feedback');
    const formatCheckbox = document.getElementById('formatCheckbox');

    let parsedStatements = [];
    let originalStatements = [];
    let currentKeptIndexes = [];

    parseBtn.addEventListener('click', () => {
      const sql = sqlInput.value.trim();
      feedback.textContent = '';
      feedback.className = '';
      tableContainer.innerHTML = '';
      outputSql.value = '';
      parsedStatements = [];
      originalStatements = [];
      currentKeptIndexes = [];
      removeBtn.disabled = true;

      if (!sql) {
        showError('INSERT文を入力してください。');
        return;
      }

      try {
        const statements = splitInsertStatements(sql);
        if (statements.length === 0) {
          throw new Error('INSERT文が見つかりません。');
        }

        parsedStatements = statements.map(parseInsertStatement);
        if (!haveSameStructure(parsedStatements)) {
          throw new Error('INSERT文の構造が一致していません。');
        }

        originalStatements = statements;

        renderTable(parsedStatements[0].columns, parsedStatements[0].values);
        removeBtn.disabled = false;
        currentKeptIndexes = parsedStatements[0].columns.map((_, index) => index);
        const message = statements.length > 1
          ? `INSERT文を${statements.length}件解析しました。カラムを選択して削除できます。`
          : 'INSERT文を解析しました。カラムを選択して削除できます。';
        showSuccess(message);
        updateOutput(true);
      } catch (error) {
        showError(error.message);
      }
    });

    formatCheckbox.addEventListener('change', () => {
      if (parsedStatements.length === 0 || currentKeptIndexes.length === 0) {
        return;
      }
      updateOutput();
    });

    removeBtn.addEventListener('click', () => {
      if (parsedStatements.length === 0) {
        showError('先にINSERT文を解析してください。');
        return;
      }

      const checkboxes = tableContainer.querySelectorAll('input[type="checkbox"]');
      const keptIndexes = [];

      checkboxes.forEach((checkbox, index) => {
        if (!checkbox.checked) {
          keptIndexes.push(index);
        }
      });

      if (keptIndexes.length === 0) {
        showError('すべてのカラムを削除することはできません。');
        return;
      }

      currentKeptIndexes = keptIndexes;
      updateOutput();
      showSuccess('選択されたカラムを削除したINSERT文を生成しました。');
    });

    function updateOutput(useOriginal = false) {
      if (parsedStatements.length === 0 || currentKeptIndexes.length === 0) {
        outputSql.value = '';
        return;
      }

      const format = formatCheckbox.checked;
      if (useOriginal && !format && isAllColumnsKept()) {
        outputSql.value = originalStatements.join('\n\n');
        return;
      }

      const statements = parsedStatements.map(parsed =>
        generateStatement(parsed, currentKeptIndexes, format)
      );
      outputSql.value = statements.join('\n\n');
    }

    function isAllColumnsKept() {
      if (parsedStatements.length === 0) {
        return true;
      }
      return currentKeptIndexes.length === parsedStatements[0].columns.length;
    }

    function generateStatement(parsed, keptIndexes, format) {
      const keptColumns = keptIndexes.map(index => parsed.columns[index]);
      const keptValues = keptIndexes.map(index => parsed.values[index]);

      if (!format) {
        const columnsStr = keptColumns.join(', ');
        const valuesStr = keptValues.join(', ');
        return `${parsed.beforeColumns}(${columnsStr})${parsed.betweenColumnsAndValues}${parsed.valuesLead}(${valuesStr})${parsed.afterValues}`;
      }

      const beforeColumns = normalizeForFormatting(parsed.beforeColumns);
      const betweenColumnsAndValues = normalizeForFormatting(parsed.betweenColumnsAndValues);
      const valuesLead = normalizeForFormatting(parsed.valuesLead);
      const afterValues = normalizeAfterValues(parsed.afterValues);
      const indent = '    ';
      const formattedColumns = keptColumns.map(column => column.trim()).join(`,\n${indent}`);
      const formattedValues = keptValues.map(value => value.trim()).join(`,\n${indent}`);

      let statement = `${beforeColumns} (
${indent}${formattedColumns}
)`;
      if (betweenColumnsAndValues) {
        statement += ` ${betweenColumnsAndValues}`;
      }
      if (valuesLead) {
        statement += ` ${valuesLead}`;
      }
      statement += ` (
${indent}${formattedValues}
)`;
      if (afterValues) {
        statement += afterValues.startsWith(';') ? `${afterValues}` : ` ${afterValues}`;
      }
      return statement;
    }

    function showError(message) {
      feedback.textContent = message;
      feedback.className = 'error';
    }

    function showSuccess(message) {
      feedback.textContent = message;
      feedback.className = 'success';
    }

    function renderTable(columns, values) {
      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const headerRow = document.createElement('tr');

      const selectHeader = document.createElement('th');
      selectHeader.textContent = '削除';
      headerRow.appendChild(selectHeader);

      const columnHeader = document.createElement('th');
      columnHeader.textContent = 'カラム名';
      headerRow.appendChild(columnHeader);

      const valueHeader = document.createElement('th');
      valueHeader.textContent = '値';
      headerRow.appendChild(valueHeader);

      thead.appendChild(headerRow);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');

      columns.forEach((column, index) => {
        const row = document.createElement('tr');

        const selectCell = document.createElement('td');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        selectCell.appendChild(checkbox);
        row.appendChild(selectCell);

        const columnCell = document.createElement('td');
        columnCell.textContent = column.trim();
        row.appendChild(columnCell);

        const valueCell = document.createElement('td');
        valueCell.textContent = values[index].trim();
        row.appendChild(valueCell);

        tbody.appendChild(row);
      });

      table.appendChild(tbody);
      tableContainer.innerHTML = '';
      tableContainer.appendChild(table);
    }

    function parseInsertStatement(sql) {
      const valuesIndex = sql.toUpperCase().indexOf('VALUES');
      if (valuesIndex === -1) {
        throw new Error('VALUES句が見つかりません。');
      }

      const beforeValues = sql.slice(0, valuesIndex);
      const valuesPart = sql.slice(valuesIndex);

      const columnOpenIndex = beforeValues.indexOf('(');
      if (columnOpenIndex === -1) {
        throw new Error('カラム定義の開始括弧が見つかりません。');
      }

      const columnCloseIndex = findMatchingParenthesis(beforeValues, columnOpenIndex);
      if (columnCloseIndex === -1) {
        throw new Error('カラム定義の終了括弧が見つかりません。');
      }

      const columnsSection = beforeValues.slice(columnOpenIndex + 1, columnCloseIndex);
      const beforeColumns = beforeValues.slice(0, columnOpenIndex);
      const betweenColumnsAndValues = beforeValues.slice(columnCloseIndex + 1);

      const valuesOpenIndex = valuesPart.indexOf('(');
      if (valuesOpenIndex === -1) {
        throw new Error('VALUES句の開始括弧が見つかりません。');
      }

      const valuesCloseIndex = findMatchingParenthesis(valuesPart, valuesOpenIndex);
      if (valuesCloseIndex === -1) {
        throw new Error('VALUES句の終了括弧が見つかりません。');
      }

      const valuesSection = valuesPart.slice(valuesOpenIndex + 1, valuesCloseIndex);
      const valuesLead = valuesPart.slice(0, valuesOpenIndex);
      const afterValues = valuesPart.slice(valuesCloseIndex + 1);

      const columns = splitTopLevel(columnsSection);
      const values = splitTopLevel(valuesSection);

      if (columns.length !== values.length) {
        throw new Error('カラム数と値の数が一致しません。');
      }

      return {
        columns,
        values,
        beforeColumns,
        valuesLead,
        betweenColumnsAndValues,
        afterValues
      };
    }

    function findMatchingParenthesis(text, openIndex) {
      let depth = 0;
      let inString = false;

      for (let i = openIndex; i < text.length; i++) {
        const char = text[i];

        if (char === "'") {
          if (inString) {
            if (text[i + 1] === "'") {
              i += 1;
            } else {
              inString = false;
            }
          } else {
            inString = true;
          }
          continue;
        }

        if (inString) {
          continue;
        }

        if (char === '(') {
          depth += 1;
        } else if (char === ')') {
          depth -= 1;
          if (depth === 0) {
            return i;
          }
        }
      }
      return -1;
    }

    function splitTopLevel(section) {
      const parts = [];
      let current = '';
      let depth = 0;
      let inString = false;

      for (let i = 0; i < section.length; i++) {
        const char = section[i];

        if (char === "'") {
          current += char;
          if (inString) {
            if (section[i + 1] === "'") {
              current += "'";
              i += 1;
            } else {
              inString = false;
            }
          } else {
            inString = true;
          }
          continue;
        }

        if (!inString) {
          if (char === '(') {
            depth += 1;
          } else if (char === ')') {
            depth -= 1;
          } else if (char === ',' && depth === 0) {
            parts.push(current.trim());
            current = '';
            continue;
          }
        }

        current += char;
      }

      if (current.trim() !== '') {
        parts.push(current.trim());
      }

      return parts;
    }

    function splitInsertStatements(sql) {
      const normalized = sql.replace(/\r\n/g, '\n');
      const statements = [];
      let current = '';
      let inString = false;

      for (let i = 0; i < normalized.length; i++) {
        const char = normalized[i];
        current += char;

        if (char === "'") {
          if (inString) {
            if (normalized[i + 1] === "'") {
              current += "'";
              i += 1;
            } else {
              inString = false;
            }
          } else {
            inString = true;
          }
          continue;
        }

        if (inString) {
          continue;
        }

        if (char === ';') {
          if (current.trim()) {
            statements.push(current.trim());
          }
          current = '';
          continue;
        }

        if (char === '\n') {
          const remaining = normalized.slice(i + 1);
          if (/^\s*INSERT/i.test(remaining)) {
            if (current.trim()) {
              statements.push(current.trim());
            }
            current = '';
          }
        }
      }

      if (current.trim()) {
        statements.push(current.trim());
      }

      return statements;
    }

    function haveSameStructure(parsedArray) {
      if (parsedArray.length <= 1) {
        return true;
      }

      const reference = parsedArray[0];
      return parsedArray.every(parsed => {
        if (reference.columns.length !== parsed.columns.length) {
          return false;
        }

        for (let i = 0; i < reference.columns.length; i++) {
          if (reference.columns[i].trim() !== parsed.columns[i].trim()) {
            return false;
          }
        }

        return (
          normalizeStructure(reference.beforeColumns) === normalizeStructure(parsed.beforeColumns) &&
          normalizeStructure(reference.betweenColumnsAndValues) === normalizeStructure(parsed.betweenColumnsAndValues) &&
          normalizeStructure(reference.valuesLead) === normalizeStructure(parsed.valuesLead) &&
          normalizeStructure(reference.afterValues) === normalizeStructure(parsed.afterValues)
        );
      });
    }

    function normalizeStructure(text) {
      if (!text) {
        return '';
      }
      return text.replace(/\s+/g, ' ').trim();
    }

    function normalizeForFormatting(text) {
      if (!text) {
        return '';
      }
      return text.replace(/\s+/g, ' ').trim();
    }

    function normalizeAfterValues(text) {
      if (!text) {
        return '';
      }
      return text.replace(/\s+/g, ' ').trim();
    }
  </script>
</body>
</html>